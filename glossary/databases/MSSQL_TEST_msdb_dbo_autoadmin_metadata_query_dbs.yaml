name: autoadmin_metadata_query_dbs
fullyQualifiedName: MSSQL_TEST.msdb.dbo.autoadmin_metadata_query_dbs
storedProcedureCode:
  language: SQL
  code: "\r\nCREATE   PROCEDURE autoadmin_metadata_query_dbs\r\n        @task_agent_guid\
    \ \tUNIQUEIDENTIFIER,\r\n        @schema_version \tINT,\r\n        @db_name \t\
    \t\tSYSNAME = NULL\r\nAS\r\nBEGIN\r\n    IF (@task_agent_guid IS NULL) OR (@schema_version\
    \ IS NULL)\r\n    BEGIN\r\n    RAISERROR ('All parameters except @db_name must\
    \ be non-NULL. Cannot complete auto-admin query for databases', -- Message text.\r\
    \n               17, -- Severity,\r\n               1); -- State\r\n    RETURN\r\
    \n    END\r\n\r\n    -- The first part of this proc updates all autoadmin tables\
    \ based on the current set of databases\r\n\r\n    SET NOCOUNT ON\r\n\r\n    --\
    \ Updates Step 1: For every existing database that does not have a row in autoadmin_managed_databases\r\
    \n    -- insert a new row into autoadmin_managed_databases\r\n    --\r\n    BEGIN\
    \ TRANSACTION\r\n        DECLARE @result INT\r\n\t\tDECLARE @empty_guid UNIQUEIDENTIFIER\r\
    \n\t\t\r\n\t\tSET @empty_guid = '00000000-0000-0000-0000-000000000000'\r\n\r\n\
    \        -- To avoid issues arising from two threads trying to refresh agent metadata\
    \ at the same time we allow only one thread to \r\n        -- proceed at a time\
    \ using the application lock below. However if a thread has to wait on the lock,\
    \ it needn't do \r\n        -- a full refresh since the data was very recently\
    \ refreshed. We just return whatever we have in our metadata tables.\r\n     \
    \   --\r\n        EXEC @result = sp_getapplock @Resource = N'SSMBack2WAMetadataRefresh',\r\
    \n                                     @LockMode  = N'Exclusive',\r\n        \
    \                             @DbPrincipal = N'dbo'\r\n\r\n        IF @result\
    \ = 1\t-- Lock was granted after some wait, meaning another thread was refreshing.\
    \ No need to refresh again.\r\n        BEGIN\r\n             GOTO release;\r\n\
    \        END\r\n        ELSE IF @result <> 0\r\n        BEGIN\r\n            \
    \ RAISERROR ('Application lock couldn''t be granted for refreshing agent metadata',\
    \ -- Message text.\r\n                              17, -- Severity,\r\n     \
    \                         2); -- State\r\n             RETURN\r\n        END\t\
    \r\n\t\r\n        BEGIN TRY\r\n\t\tINSERT INTO autoadmin_managed_databases (db_name,\
    \ db_id, db_guid, group_db_guid, drop_date)\r\n\t\tSELECT dbs.name, dbs.database_id,\
    \ dbrs.database_guid, dbs.group_database_id, NULL\r\n\t\t    FROM sys.databases\
    \ dbs\r\n\t\t    INNER JOIN sys.database_recovery_status dbrs ON dbs.database_id\
    \ = dbrs.database_id\r\n\t\t    WHERE NOT EXISTS (SELECT 1\r\n\t\t\t\t      FROM\
    \ autoadmin_managed_databases aamd\r\n\t\t\t\t      WHERE aamd.db_id = dbs.database_id\
    \ \r\n\t\t\t\t      AND QUOTENAME(aamd.db_name) = QUOTENAME(dbs.name)\r\n\t\t\t\
    \t      AND aamd.db_guid = dbrs.database_guid\r\n\t\t\t\t     )\r\n\t\t    AND\
    \ ISNULL(dbrs.database_guid, @empty_guid) <> @empty_guid\r\n\t\t\tAND dbs.source_database_id\
    \ IS NULL\r\n\r\n\t\t-- Updates Step 2: For every row in autoadmin_managed_databases\
    \ that does not have a corresponding row in \r\n\t\t-- sys.databases etc., if\
    \ drop_date is not NULL then set it to the current date/time. We use db_name and\r\
    \n\t\t-- db_id to locate a row in sys.databases. If a database is dropped and\
    \ another database is created with\r\n\t\t-- the same name immediately afterwards,\
    \ it might get the same db_id; in which case db_guid will be used to \r\n\t\t\
    -- distinguish the databases. However, if a database is set to OFFLINE, its db_guid\
    \ becomes NULL and we might \r\n\t\t-- incorrectly mark the database as dropped\
    \ as the db_guids won't match. So, we specially handle NULL and empty \r\n\t\t\
    -- GUIDs. The query will also unmark a detached database as dropped if it is re-attached\
    \ in the same instance.\r\n\t\t--\r\n\t\tUPDATE aamd\r\n\t\tSET aamd.drop_date\
    \ = \r\n\t\t\t(\r\n\t\t\t\tCASE \r\n\t\t\t\tWHEN NOT EXISTS \r\n\t\t\t\t\t(\r\n\
    \t\t\t\t\t\tSELECT 1\r\n\t\t\t\t\t\tFROM sys.databases dbs\r\n\t\t\t\t\t\tJOIN\
    \ sys.database_recovery_status dbrs\r\n\t\t\t\t\t\tON dbs.database_id = dbrs.database_id\r\
    \n\t\t\t\t\t\tWHERE dbs.database_id = aamd.db_id\r\n\t\t\t\t\t\tAND QUOTENAME(dbs.name)\
    \ = QUOTENAME(aamd.db_name)\r\n\t\t\t\t\t\tAND (dbrs.database_guid = aamd.db_guid\r\
    \n\t\t\t\t\t\tOR ISNULL(dbrs.database_guid, @empty_guid) = @empty_guid)\r\n\t\t\
    \t\t\t) \r\n\t\t\t\tTHEN ISNULL(aamd.drop_date, SYSDATETIME())\r\n\t\t\t\tELSE\
    \ NULL\r\n\t\t\t\tEND\r\n\t\t\t)\r\n\t\tFROM autoadmin_managed_databases aamd\r\
    \n\r\n\t\t-- Updates Step 3: Update the group_database_id for databases if changed\
    \ since last read. This happens when a database\r\n\t\t-- joins or leaves an availability\
    \ group.\r\n\t\t--\r\n\t\tUPDATE aamd\r\n\t\tSET aamd.group_db_guid = dbs.group_database_id\r\
    \n\t\tFROM sys.databases dbs\r\n\t\tINNER JOIN sys.database_recovery_status dbrs\
    \ ON dbs.database_id = dbrs.database_id\r\n\t\tINNER JOIN autoadmin_managed_databases\
    \ aamd\r\n\t\t     ON aamd.db_id = dbs.database_id \r\n\t\t     AND QUOTENAME(aamd.db_name)\
    \ = QUOTENAME(dbs.name)\r\n\t\t     AND aamd.db_guid = dbrs.database_guid\r\n\t\
    \tWHERE ISNULL(aamd.group_db_guid, 0x0) <> ISNULL(dbs.group_database_id, 0x0)\r\
    \n\r\n\t\t-- Updates Step 4: For every existing database that does not have a\
    \ row in autoadmin_task_agent_metadata for the calling task agent\r\n\t\t-- insert\
    \ a new row into autoadmin_task_agent_metadata.\r\n\t\t--\r\n\t\tINSERT INTO autoadmin_task_agent_metadata\
    \ (task_agent_guid, autoadmin_id, last_modified, task_agent_data)\r\n\t\tSELECT\
    \ @task_agent_guid, aamd.autoadmin_id, CURRENT_TIMESTAMP, NULL\r\n\t\t    FROM\
    \ sys.databases dbs\r\n\t\t    INNER JOIN sys.database_recovery_status dbrs ON\
    \ dbs.database_id = dbrs.database_id\r\n\t\t    INNER JOIN autoadmin_managed_databases\
    \ aamd\r\n\t\t\t     ON aamd.db_id = dbs.database_id \r\n\t\t\t     AND QUOTENAME(aamd.db_name)\
    \ = QUOTENAME(dbs.name)\r\n\t\t\t     AND aamd.db_guid = dbrs.database_guid\r\n\
    \t\t    LEFT OUTER JOIN autoadmin_task_agent_metadata aatam ON aatam.autoadmin_id\
    \ = aamd.autoadmin_id AND aatam.task_agent_guid = @task_agent_guid\r\n\t\t   \
    \ WHERE \r\n\t\t\t\taatam.task_agent_guid IS NULL \r\n\t\t\t\tAND aamd.drop_date\
    \ IS NULL\r\n\t\t\t\tAND dbs.source_database_id IS NULL\r\n        END TRY\r\n\
    \tBEGIN CATCH\r\n\t\tEXEC sp_releaseapplock @DbPrincipal = 'dbo', @Resource =\
    \ 'SSMBack2WAMetadataRefresh';\r\n\t\tTHROW\r\n\tEND CATCH\r\n\r\nrelease:\r\n\
    \    EXEC sp_releaseapplock @DbPrincipal = 'dbo', @Resource = 'SSMBack2WAMetadataRefresh';\r\
    \n\r\n    COMMIT TRANSACTION\r\n\r\n    -- Updates are now complete.\r\n    --\
    \ The second part of this proc returns a join of database metadata and associated\
    \ autoadmin metadata\r\n\r\n    -- Do a join of sys.databases, sys.database_recovery_status,\
    \ sys.database_mirroring, autoadmin_managed_databases and autoadmin_task_agent_metadata.\r\
    \n    -- The returned rowset will appear as follows:\r\n    -- Existing databases\
    \ will have columns for most tables (exception is sys.database_mirroring.mirroring_role\
    \ which may be NULL)\r\n    -- Dropped databases that have not be deleted by the\
    \ specified task agent will have columns in autoadmin_managed_databases and autoadmin_task_agent_metadata.\r\
    \n    -- Dropped databases that have been deleted by the specified task agent\
    \ will not have any rows\r\n    --\r\n\t\r\n\tSET @db_name = ISNULL(@db_name,\
    \ '')\r\n\r\n\tSELECT\r\n\tdbs.state db_state,\r\n\tdbs.create_date db_create_date,\r\
    \n\tdbs.recovery_model db_recovery_model, \r\n\tdbs.is_read_only db_read_only,\
    \ \r\n\tdbs.target_recovery_time_in_seconds db_recovery_time, \r\n\tdbm.mirroring_role\
    \ db_mirroring_role,\r\n\taamd.db_name db_name,\r\n\taamd.db_id db_id,\r\n\taamd.db_guid\
    \ db_guid,\r\n\taamd.group_db_guid group_db_guid,\r\n\t(SELECT group_id FROM sys.dm_hadr_database_replica_states\
    \ WHERE group_database_id = aamd.group_db_guid AND is_local = 1) group_guid,\r\
    \n\taamd.drop_date drop_date,\r\n\tsys.fn_hadr_backup_is_preferred_replica(db_name)\
    \ as is_preferred_backup_replica,\r\n\taatam.last_modified last_modified,\r\n\t\
    aatam.task_agent_data task_agent_data,\r\n\taatam.schema_version schema_version\r\
    \n\tFROM sys.databases dbs \r\n\tINNER JOIN sys.database_recovery_status dbrs\
    \ ON dbs.database_id = dbrs.database_id\r\n\tINNER JOIN sys.database_mirroring\
    \ dbm ON dbm.database_id = dbs.database_id\r\n\tRIGHT OUTER JOIN autoadmin_managed_databases\
    \ aamd ON aamd.db_id = dbs.database_id and aamd.db_guid = dbrs.database_guid\r\
    \n\tINNER JOIN autoadmin_task_agent_metadata aatam ON aatam.autoadmin_id = aamd.autoadmin_id\
    \ AND aatam.task_agent_guid = @task_agent_guid\r\n\tWHERE \r\n\t(\r\n\t\tQUOTENAME(@db_name)\
    \ = QUOTENAME('') OR\r\n\t\tQUOTENAME(@db_name) = QUOTENAME(aamd.db_name)\r\n\t\
    )\r\n\tAND @schema_version = aatam.schema_version\r\n\tAND dbs.source_database_id\
    \ IS NULL\r\nEND\r\n"
dataProducts: []
databaseSchema:
  id: 57c2f396-9b05-4e00-9903-62b0219fbc25
  type: databaseSchema
  name: dbo
  fullyQualifiedName: MSSQL_TEST.msdb.dbo
  displayName: dbo
  deleted: false
database:
  id: af8db866-dbb4-4bd5-a2ea-22202fbc71ef
  type: database
  name: msdb
  fullyQualifiedName: MSSQL_TEST.msdb
  displayName: msdb
  deleted: false
service:
  id: 1ef4c8da-1280-42c0-8b83-142c3a019de7
  type: databaseService
  name: MSSQL_TEST
  fullyQualifiedName: MSSQL_TEST
  description: ""
  displayName: MSSQL_TEST
  deleted: false
serviceType: Mssql
owners: []
tags: []
domains: []
sourceHash: a7fe43e69538fb96245d7de6f72edaa1
processedLineage: false
entityStatus: Approved
